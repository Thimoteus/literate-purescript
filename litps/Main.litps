This is a literate purescript file. All the development of `literate-purescript`
happens in a `.litps` file, then the transpiler is called on the literate source.

> module Main where
> 
> import Prelude
> import Control.Monad (when)
> import Control.Monad.Eff
> import Control.Monad.Eff.Exception (EXCEPTION())
> import Control.Monad.Eff.Console
> 
> import Data.Array (drop, head, filter, zip, concatMap)
> import Data.Maybe (Maybe(..), fromMaybe)
> import Data.Foldable (for_)
> import Data.Traversable (traverse)
> import Data.Tuple (Tuple(..), fst, snd)
> import Data.String (dropWhile, length)
> 
> import Node.Path (FilePath(), dirname)
> import Node.Encoding (Encoding(..))
> import Node.FS (FS())
> import Node.FS.Sync (readTextFile, writeTextFile, exists, stat, readdir, mkdir)
> import Node.FS.Stats (Stats(), isDirectory, isFile)
> import Node.Process (argv)
> 
> import Literate.Parser (transpile)

First we take care of some necessary imports.

> type RecursivEff a = forall e. Eff ( fs :: FS, err :: EXCEPTION | e ) a

Type synonym to make signatures easier to read.

> getDirFiles :: FilePath -> RecursivEff (Tuple (Array String) (Array String))
> getDirFiles root = do
>   contents <- map (\ x -> root <> "/" <> x) <$> readdir root
>   stats <- traverse stat contents
>   let files = map fst <<< filter snd <<< zip contents <<< map isFile $ stats
>       dirs = map fst <<< filter snd <<< zip contents <<< map isDirectory $ stats
>   pure $ Tuple dirs files

Takes a `FilePath` (assumed to be a directory) and returns a tuple (xs, ys)
where xs is all the directories under the given directory and ys is all the
files inside the given directory.

> recursivelyGetDirFiles :: String -> RecursivEff (Tuple (Array String) (Array String))
> recursivelyGetDirFiles root = do
>   dirFiles <- getDirFiles root
>   let dirs = fst dirFiles
>       files = snd dirFiles
>   s <- traverse recursivelyGetDirFiles dirs
>   let newDirs = concatMap fst s
>       newFiles = concatMap snd s
>   pure $ Tuple (dirs <> newDirs) (files <> newFiles)

Applies `getDirFiles` recursively, concatenating all found folders into the
fst part of the tuple, and all found files into the snd part.

> writeSingleFile :: FilePath -> String -> RecursivEff Unit
> writeSingleFile path contents = do
>   makeSurePathExists path
>   writeTextFile UTF8 (path <> ".purs") (transpile contents)

Takes a `FilePath` and the (literate) contents to write. First it makes sure
the dirname of the path exists, then it transpiles the contents, and writes them
to a file with ".purs" added to the end.

> makeSurePathExists :: FilePath -> RecursivEff Unit
> makeSurePathExists path = do
>   let dir = dirname path
>   doesExist <- exists dir
>   when (not doesExist) $ mkdir dir

Gets the dirname of a given path. If it exists, nothing is done; if it doesn't,
the directory is created.

> readSingleFile :: FilePath -> RecursivEff String
> readSingleFile path = readTextFile UTF8 path

Reads a file as UTF8 (since we can use unicode operators now!)

> main = void do
>   folder <- fromMaybe "." <<< head <<< drop 2 <$> argv
>   files <- snd <$> recursivelyGetDirFiles folder
>   fileContents <- traverse readSingleFile files
>   outputFolder <- exists "src/"
>   when (not outputFolder) $ mkdir "src/"
>   let pathContents = zip (map (("src/" <>) <<< dropWhile (/= '/')) $ files) fileContents
>   traverse (\ x -> writeSingleFile (fst x) (snd x)) pathContents

The argument parsing drops the first two, since node puts them as "node" and
the path to file being executed.

Then it makes sure the "src/" directory exists. The file contents and new paths
(under "src/") are then zipped up into an association array.

Each (path, content) pair is then written to the output folder (in this case,
"src/").
