```purescript
module Literate.Parser where

import Prelude

import Data.List (List(), mapMaybe)
import Data.Array (length)
import Data.Maybe (Maybe(..))
import Data.Foldable (foldMap, intercalate)
import Data.String (split, take)

import Control.Alt ((<|>))
import Control.Apply ((<*), (*>))

import Text.Parsing.Simple
import Text.Parsing.Combinators hiding (many, many1)

data Line = Comment String
          | Code String
          | Empty

instance showLine :: Show Line where
  show (Comment s) = "Comment " <> show s
  show (Code s) = "Code " <> show s
  show Empty = ""
```

Mostly for debugging in PSCI.

```purescript
line :: Parser String
line = fromCharList <$> many1 (sat (/= '\n')) <* skip newline
```

A line is just a string of characters followed by a newline, or the end of the file.

```purescript
emptyLine :: Parser Line
emptyLine = string "\n" *> pure Empty
```

An empty line is a line that models the empty string.

```purescript
fromCode :: Line -> Maybe String
fromCode (Code s) = Just s
fromCode _ = Nothing

code :: Parser Line
code = ticked <|> birdTracks <|> indented
```

code can be surrounded by triple ticks, prefaced with Bird tracks, or indented.

```purescript
ticked :: Parser Line
ticked = bracket ticks goodStuff ticks

ticks :: Parser Unit
ticks = string "```" *> skip (string "purescript") *> skipSpaces

goodStuff :: Parser Line
goodStuff = Code <<< intercalate "\n" <$> many noTickLine

noTickLine :: Parser String
noTickLine = (line |= \ l -> take 3 l /= "```") <> (string "\n" *> pure "")
```

a noTickLine does not start with three ticks.

    indented :: Parser Line
    indented = Code <$> (exactly 4 space *> line)

indented lines have at least 4 spaces, followed by a line. We use `exactly`
here because `atLeast` is greedy in the `space` parser.

> birdTracks :: Parser Line
> birdTracks = Code <$> (string "> " *> line) --*

```purescript
comment :: Parser Line
comment = Comment <$> (skipSpaces *> line)
```

Comments are anything that isn't code.

```purescript
document :: Parser (List Line)
document = many (emptyLine <> code <> comment)
```

A document is a function that takes its maximum length (in lines of code) and
produces a parser for a list of lines.

```purescript
renderCode :: Line -> String
renderCode (Code s) = s
renderCode _ = ""

renderProgram :: List Line -> String
renderProgram = foldMap (<> "\n") <<< mapMaybe fromCode
```

First we discard the comments, then we join all the code lines with a newline.

```purescript
numberOfNewlines :: String -> Int
numberOfNewlines = length <<< split "\n"
```

An easy way of getting the length of a document.

```purescript
transpile :: String -> String
transpile p = case renderProgram <$> parse document p of
                   Just x -> x
                   Nothing -> "ERROR: The \"impossible\" happened."
```

First we parse a document, then we render it, producing a new `String`.

Note: Since the `document` parser is defined in terms of `atMost` (which never fails),
the `Nothing` case is impossible.
